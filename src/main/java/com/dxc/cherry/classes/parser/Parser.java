package com.dxc.cherry.classes.parser;

import java.util.List;

import com.dxc.cherry.exceptions.InvalidExpressionException;

/*
 * The Parser class is responsible for parsing a list of tokens, generated by the Lexer and constructing the abstract syntax tree.
 * 
 */
public class Parser {

	private int pos = 0;
	private Token curr_token = null;
	private final List<Token> tokens;
	private boolean inBrackets = false;
	
	/**
     * Constructs a Parser object with the given list of tokens to be parsed.
     *
     * @param tokens A List of Token objects representing the tokens generated by the Lexer.
     */
	public Parser(List<Token> tokens) {
		this.tokens = tokens;
		getNext();
	}

	/**
     * Parses the input expression and constructs the Abstract Syntax Tree (AST).
     *
     * @return The root node of the Abstract Syntax Tree (AST).
     * @throws InvalidExpressionException If the input expression is not a valid mathematical expression or contains mismatched parentheses.
     */
	public ASTNode parseExpression() throws InvalidExpressionException {

		ASTNode result = Factor();

		while (curr_token.getType() != Token.Type.END_OF_INPUT  &&
				(curr_token.getType() == Token.Type.PLUS || curr_token.getType() == Token.Type.MINUS)) {
			if (curr_token.getType() == Token.Type.PLUS) {
				getNext();
				ASTNode rightNode = Factor();
				result =  new ASTNode("+", result, rightNode);
			} else if (curr_token.getType() == Token.Type.MINUS) {
				getNext();
				ASTNode rightNode = Factor();
				result =  new ASTNode("-", result, rightNode);
			}
		}
		
		if (curr_token.getType() == Token.Type.RIGHT_PAREN && !inBrackets) {
			throw new InvalidExpressionException("Right bracket without an opening left bracket!");
		}
		
		return result;

	}

	/**
     * A private helper method that parses the input expression and constructs the Abstract Syntax Tree (AST) for division and multiplication operations.
     *
     * @return The root node of the Abstract Syntax Tree (AST).
     * @throws InvalidExpressionException If the input expression is not a valid mathematical expression or contains mismatched parentheses.
     */	private ASTNode Factor() throws InvalidExpressionException {
		ASTNode factor = Term();

		while (curr_token.getType() != Token.Type.END_OF_INPUT &&
				(curr_token.getType() == Token.Type.MULTIPLY || curr_token.getType() == Token.Type.DIVIDE)) {
			if (curr_token.getType() == Token.Type.MULTIPLY) {
				getNext();
				ASTNode rightNode = Term();
				factor =  new ASTNode("*", factor, rightNode);
			} else if (curr_token.getType() == Token.Type.DIVIDE) {
				getNext();
				ASTNode rightNode = Term();
				factor =  new ASTNode("/", factor, rightNode);
			}
		}
		
		if (curr_token.getType() == Token.Type.RIGHT_PAREN && !inBrackets) {
			throw new InvalidExpressionException("Right bracket without an opening left bracket!");
		}
		
		return factor;
	}

     /**
      * A private helper method that calculates and manages expressions, containing brackets.
      *
      * @return The root node of the Abstract Syntax Tree (AST).
      * @throws InvalidExpressionException If the input expression is  expression or contains mismatched parentheses.
      */
	private ASTNode Term() throws InvalidExpressionException {
		ASTNode term = null;
		
		if (curr_token.getType() == Token.Type.LEFT_PAREN) {
			inBrackets = true;
			getNext();
			term = parseExpression();
			if (curr_token.getType() != Token.Type.RIGHT_PAREN) {
				throw new InvalidExpressionException("Left bracket without a closing right bracket!");
			}
			inBrackets = false;
		} else if (curr_token.getType() == Token.Type.NUMBER) {
			term = new ASTNode(curr_token.getLexeme(), null, null);
		}
		getNext();
		return term;
	}

	/*
	 * A private helper method that iterates through the list of Token objects and changes the current token.
	 */
	private void getNext() {
		if (pos < tokens.size()) {
			curr_token = tokens.get(pos);
			pos++;
		}
	}

}
